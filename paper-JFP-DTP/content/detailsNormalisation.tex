\section {Normalisation functions and re-usability of the provers}

We now describe briefly how the normalisation functions work for some of the structures, and we also explain how we've been able to reuse each prover for the more specialised underneath structures. 

	\subsection {Normalization of terms in a Semi-Group}
In a semigroup, we only have to deal with the property of associativity. As it was the case with the toy example in the previous section, we will have to rearrange the parenthesis on a systematical way, either left associative, or right associative. But this is not the only thing that we have to do. If $x$, $y$ and $z$ denote variables, we don't only want to transform $x+((y+4)+(5+z))$ into $(((x+y)+4)+5)+z$ if we've chosen the complete left associative form. We want first to do the addition of the constants $4$ and $5$ together (and we have the right to do so because we can rearrange the parenthesis thanks to the associativity, when constants are, like in this case, near to each other). Three possible patterns need this treatment : $(x+c1)+(c2+y)$ , $(x + c1) + c2$  and $c1 + (c2 + x)$ when $c1$ and $c2$ denote constants. The simplification between the constants $c1$ and $c2$ is denoted here as $[c1+c2]$, and this computation is done by the normalisation function of the underneath $Magma$ level, called $magmaReduce$.
The first pattern is rewritten into $(x + [c1+c2]) + y$, the second into $x + [c1+c2]$ and the third one into $[c1 + c2] + x$.
We show the code for the first pattern.

\begin{figure}[H]
\figrule
\begin{center}
\begin{verbatim}
assoc : (p:SemiGroup c) -> (gam:Vect n c) -> {c1:c} 
        -> (ExprSG p gam c1) -> (c2 ** (ExprSG p gam c2, c1=c2))
assoc p gam (PlusSG 
             (PlusSG e1 (ConstSG _ _ c1)) 
             (PlusSG (ConstSG _ _ c2) e2)) =
    let (r_ih1 ** (e_ih1, p_ih1)) = (assoc p gam e1) in
    let (r_ih2 ** (e_ih2, p_ih2)) = (assoc p gam e2) in
    let (r_3 ** (e_3, p_3)) = magmaReduce (semiGroup_to_magma 
                             (PlusSG (ConstSG _ _ c1) (ConstSG _ _ c2))) in
    let e_3' = magma_to_semiGroup p e_3 in
        (_ ** ((PlusSG (PlusSG e_ih1 e_3') e_ih2), ?Massoc1))
[...]
\end{verbatim}
\end{center}
\caption{Computing with associativity in a Semi-Group, first pattern}
\figrule
\end{figure}

Note that we use function of conversions between the different levels : $semiGroup\_to\_magma$ and $magma\_to\_semiGroup$.

After simplifying the constants computable thanks to associativity, the normalization for SemiGroup also has to rearrange the brackets on a systematic way. The fully right or fully left associative forms can both be chosen for this purpose, and the implementation is very similar to the function $expr_l$ previously described on section 2.3.

\subsection {Normalization of terms in a Monoid}

In a monoid, we simply have to eliminate zeros, thanks to the two properties of left and right neutrality. Because the simplification of additions between a zero and a constant has be done at the underneath level of semigroup (by computing the addition of these two constants), we only have to simplify the addition between the constant zero and a variable. There is in fact two cases, since the variable can come first, or the $Zero$ can come first. We can write a function $elimZero$ which rewrites these two patterns $x+Z$ and $Z+x$ as $x$.

%\begin{figure}[H]
%\figrule
%\begin{center}
%\begin{verbatim}
%elimZero : (p:Monoid c)->(gam:Vect n c)->{c1:c} 
%            -> (ExprMo p gam c1) 
%            -> (c2 ** (ExprMo p gam c2, c1=c2))
%elimZero c p gam (PlusMo (ConstMo _ _ const1) (VarMo _ v)) 
%        with (eq_on_set p Zero const1)
%   elimZero c p gam (PlusMo (ConstMo _ _ Zero) (VarMo _ v)) 
%        | (Just refl) = (_ ** (VarMo _ v, ?MelimZero1))
%   elimZero c p gam (PlusMo (ConstMo _ _ const1) (VarMo _ v)) 
%        | _ = (_ ** (PlusMo (ConstMo _ _ const1) (VarMo _ v), refl)) 
%elimZero c p gam 
% (PlusMo (VarMo _ v) (ConstMo _ _ const2)) 
%      with (eq_as_elem_of_set p Zero const2) 
%   elimZero c p gam (PlusMo (VarMo _ v) 
%            (ConstMo _ _ Zero)) | (Just refl) 
%          = (_ ** (VarMo _ _ v, ?MelimZero2))
%   elimZero c p gam (PlusMo (VarMo _ v) 
%            (ConstMo _ _ const2)) | _ 
%          = (_ ** (PlusMo (VarMo _ v) 
%                 (ConstMo _ _ const2), refl))
%[...]
%\end{verbatim}
%\end{center}
%\caption{Eliminating zeros in a Monoid, first pattern}
%\figrule
%\end{figure}

The normalization of reflected expressions in a monoid is simply made of a call to the function reducing terms on a semigroup, followed by a call to elimZero which will eliminates the remaining additions with zeros. 


\subsection {Reusing the monoid prover for building the group prover}

The first thing that the reduction function of the group prover will have to do is simply to transform every subtraction $a-b$ into $a + -b$, and we are entitled to do so precisely because we have available the property $Minus\_simpl$ contained in the instance of the type class.
After that, the reduction continues with the propagation of the $Neg$ operation inside the parenthesis and $-(a+b)$ is transformed into $(-b) + (-a)$. Note that we have to be careful and not simplify it to $(-a) + (-b)$ as it would assume that we're having a commutative monoid.
Then, because we've pushed some negations inside the parenthesis, we might have sequences of two or more consecutive negations. We simplify them by removing two consecutive negations every time that we find such a sequence. Once this is done, there is a last major step specific of groups to accomplish, which is the simplification of sums of symmetric elements. 

This might be a direct sum of symmetric elements, like $-e1 + e2$ or $e1 + -e2$ and in these two cases, we need to simplify them when $e1$ can be reduced\footnote{It is not enough to simply check their syntactical equality, as they might not be immediately equal but could perhaps be normalised to the same term. Thus, this step --which is part of the reduction function-- uses the entire reduction function, but it calls it on a smaller term} to $e2$ , and if so the result should be $Zero$. We are entitled to do this treatment because of the property $Plus\_inverse$.

The sum to simplify might be more complex, with two or three levels of of $Plus$. In these cases, there might be some simplifications to do thanks to the associativity property. With two levels of sums, we will transform $(e1 + (-e2 + e3))$ and $(-e1 + (e2+e3))$ into $e3$ when $e1$ can be normalised to $e2$. Also, $((e1+e2) + -e3))$ and $((e1+(-e2)) + e3)$ are simplified into $e1$ when $e2$ can be reduced to $e3$. Finally, in presence of three level of sums, we will transform $(a+b) + ((-c)+d)$ and $(a+(-b)) + (c+d)$ into $a+d$ when $b$ can be reduced to $c$.


The idea : negations $-x$ are encoded as variables.

\subsection {Reusing the commutative group prover for building the ring prover}

The idea : monomials (containing products), like $3*(x*y)$ are encoded as variables when passed to the commutative group prover. 
