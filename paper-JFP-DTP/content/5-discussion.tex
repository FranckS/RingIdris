\section {Discussion}

	\subsection{Comparison with a traditional approach}

Without our type-safe reflection mechanism, the traditional way to go for this problem would be to start with the definition of the function $reify\ :\ Expr\ \rightarrow\ c$. As we did in our approach, there is still a function for reflecting terms $reflect\ :\ c\ \rightarrow\ Expr$. Because $reflect$ is a function based on syntax,  the actual way to define depends on the facilities of the proof assistant / programming language used, but there need to be a way to write functions based on syntax. We need to prove the correctness of these two functions, and it turns out that one lemma is enough for completely specifying the expected behaviour of these two functions at the same time : $reflect\_and\_reify\_correct\ :\ \forall\ x:c,\ reify\ (reflect\ x)\ =\ x$.

Then comes the normalisation function : $normalize\ :\ Expr\ \rightarrow\ Expr$. Because this function is weekly typed compared to our approach (we no longer have an index giving a guarantee about the concrete values), we need to prove a lemma of correctness about it after its definition. This lemma of correctness must say that the interpretation of the original (reflected) term is equal to the interpretation of the normalised (reflected) term. $normalize\_correct\ :\ \forall\ e:Expr,\ reify\ (normalize\ e)\ =\ reify\ e$. We have avoided the need of such a --complicated-- proof in our correct by construction approach enabled by our type-safe reflection mechanism.

Now, similarly to what we've done, we need a syntactical equality test, checking whether two reflected expression are syntactically equal. The difference here is that, as often with this kind of "traditional" approach, we produce something that belongs to the world of computations, usually a (pretty uninformative) boolean.
$beq_{Expr}\ :\ Expr\ \rightarrow\ Expr\ \rightarrow\ bool$. Because this boolean on it own is pretty uninformative, we now need a proof of correctness for this function as well, which says that if this function decides that two given terms are syntactically equal, then their interpretation are also (syntactically) equal. $beq_{Expr}\_correct\ :\ \forall (e1\ e2:Expr), beq_{Expr}\ e1\ e2\ =\ true\ \rightarrow\ reify\ e1\ =\ reify\ e2$. We did not have to do this proof either with our approach.

We build now the kernel of the tactics, which is a decision procedure. 
\begin{figure}[H]
\figrule
\begin{center}
\begin{verbatim}
decideEq : c -> c -> bool 
decideEq x y =
      let xRefl = reflect x in 
      let yRefl = reflect y in
      beq_Expr (normalise xRefl) (normalise yRefl)
\end{verbatim}
\end{center}
\caption{Decision procedure}
\figrule
\end{figure}
This function on its own is not going to be enough. We need to add it a correctness theorem, and this is precisely this theorem which is going to help us build the tactic we want.	
$decideEq\_correct\ :\ \forall\  x\ y:c,\ decideEq\ x\ y\ =\ true\ \rightarrow\ x\ =\ y$. This proof can be made by combining, in this order, the three lemmas $beq_{Expr}\_correct$, $normalize\_correct$ (two times), and $reflect\_and\_reify\_correct$.

Now, the tactic can be build by using this correctness theorem. When trying to prove a goal $a\ =\ b$, the tactic will apply this theorem $decideEq\_correct$. The desired proof is produced if the premise $decideEq\ a\ b\ =\ true$ holds. But whether this premise holds or not can simply be tested by running the function $decideEq$ on the two arguments $a$ and $b$. The activity of proving has effectively been replaced by the task of running a function, and a simple evaluation is now enough to produce the desired proof.

	\subsection {Comparison with Coq's approach}
	
Exactly as above, but let the typechecker do more work.
cf extra slides 37-38 of my STP talk.

	\subsection {Correctness and completeness}

		\subsubsection{Correctness}
		
Idea : obtained by construction. In fact, what we really needed to produce was the proof of equality, and not the normalised terms. The only two things we have to ensure are :
\begin{itemize}
\item not having introduces any axioms
\item not having introduced any non total function (is it really needed in fact if all this stuff only exists at typecheck and not at runtime? I guess it's fine as long as we haven't used non-total functions to illegitimately extract proof of lemmas)
\end{itemize}

If we meet the two conditions above, we simply can't produce a false proof of a statement, because the typechecker would complain. Like in Coq's approach where they just see if the typecheck is ok to apply $f\_correct\ (reflect\ a)\ (reflect\ b)$ in order to prove $a=b$. The typecheck only agrees if $reify\ (reflect\ a) = reify(reflect\ b)$ can be unified with $a=b$, which is the case if the $reify$ and $reflect$ functions have been correctly defined.
		
		\subsubsection{Completeness}
		
Idea 1 : Having a complete tactic is important, because otherwise the tactic is not usable often, and thus is not really valuable. However, having a formal proof of the completeness in the system itself isn't really interesting. As long as we do not meet an equality that should be provable, and which isn't proved by our tactic, there is no problem. And if this situation does happen, nothing really bad really happened : no inconsistencies have been introduced, etc. The tactic just refuses to do it automatically for the programmer. The human can still try to attempt it. \\
\\
Idea 2 : Completeness is not, as one could imagine : \\
$a=b \rightarrow norm\ (reflect\ a) = norm\ (reflect\ b)$
The reason is that we could just rewrite the hypothesis in the goal, without having to inspect the behaviour of the $norm$ function. That would prove nothing interesting.
Completeness is in fact $norm\ (reflect\ a) \neq norm(reflect\ b) \rightarrow a \neq b$, which is in fact :
$decideEq\ (reflect\ a)\ (reflect\ b) = Nothing \rightarrow a \neq b$.
This thing is terrible to prove in the proof assistant. It has never been done for this problem (not for Coq's ring prover, not for Agda ring prover). Can I do it for the little example with natural numbers though ? \\
\\
Idea 3 : We have the guarantee that we aren't losing any totality because of the $reflect$ function because of our index ! This is another extra advantage of our approach. We know that $reify\ (reflect\ a)$ is always unifiable with $a$ in our case. Coq's approach doesn't have this guarantee, and could potentially lose some completeness if this property is not always true.