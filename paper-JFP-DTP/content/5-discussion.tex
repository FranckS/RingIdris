\section {Discussion}


	\subsection{Comparison with a traditional approach}

Without our type-safe reflection mechanism, the traditional way to go for this problem would be to have functions doing only computations, and some external lemmas about them. It would start with the definition of the function $reify\ :\ Expr\ \rightarrow\ c$. As we did in our approach, there is still a function for reflecting terms $reflect\ :\ c\ \rightarrow\ Expr$. Because $reflect$ is a function based on syntax,  the actual way to define depends on the facilities of the proof assistant / programming language used, but there need to be a way to write functions based on syntax. We need to prove the correctness of these two functions, and it turns out that one lemma is enough for completely specifying the expected behaviour of these two functions at the same time : $reflect\_and\_reify\_correct\ :\ \forall\ x:c,\ reify\ (reflect\ x)\ =\ x$.

Then comes the normalisation function : $normalize\ :\ Expr\ \rightarrow\ Expr$. Because this function is weekly typed compared to our approach (we no longer have an index giving a guarantee about the concrete values), we need to provide a lemma of correctness about it after its definition. This lemma of correctness must say that the interpretation of the original (reflected) term is equal to the interpretation of the normalised (reflected) term. $normalize\_correct\ :\ \forall\ e:Expr,\ reify\ (normalize\ e)\ =\ reify\ e$. We have avoided the need of such a --complicated-- proof in our correct by construction approach enabled by our type-safe reflection mechanism.

Now, similarly to what we've done, we need a syntactical equality test, checking whether two reflected expressions are syntactically equal. The difference here is that, as often with this kind of "traditional" approach, we produce something that belongs to the world of computations, usually a (pretty uninformative) boolean.
$beq_{Expr}\ :\ Expr\ \rightarrow\ Expr\ \rightarrow\ bool$. Because this boolean on its own is pretty uninformative, we now need a proof of correctness for this function as well, which says that if this function decides that two given terms are syntactically equal, then their interpretation are also (syntactically) equal. $beq_{Expr}\_correct\ :\ \forall (e1\ e2:Expr), beq_{Expr}\ e1\ e2\ =\ true\ \rightarrow\ reify\ e1\ =\ reify\ e2$. We did not have to do this proof either with our approach.

We now build the kernel of the tactics, which is the following decision procedure. 
\begin{figure}[H]
\figrule
\begin{center}
\begin{verbatim}
decideEq : c -> c -> bool 
decideEq x y =
      let xRefl = reflect x in 
      let yRefl = reflect y in
      beq_Expr (normalise xRefl) (normalise yRefl)
\end{verbatim}
\end{center}
\caption{Decision procedure of the tactic with a "traditional" approach}
\figrule
\end{figure}
This function on its own is not going to be enough. We need to add it a correctness theorem, and this is precisely this main theorem which is going to help us build the tactic we want.	
$decideEq\_correct\ :\ \forall\  x\ y:c,\ decideEq\ x\ y\ =\ true\ \rightarrow\ x\ =\ y$. This proof can be made by combining, in this order, the three lemmas $beq_{Expr}\_correct$, $normalize\_correct$ (two times, one on each side of the assumed equality), and finally $reflect\_and\_reify\_correct$ (again two times).

Now, the tactic can be build by using this correctness theorem. When trying to prove a goal $a\ =\ b$, the tactic will apply this theorem $decideEq\_correct$, which means that $x$ will be unified to $a$ and $y$ to $b$. The desired proof is thus produced if the premise $decideEq\ a\ b\ =\ true$ holds. But whether this premise holds or not can simply be tested by running the function $decideEq$ on the two arguments $a$ and $b$. 

Both with this "traditional" approach or with our type-safe reflection, the activity of proving has effectively been replaced by the task of running a function, and a simple evaluation is now enough to produce the desired proof.

	\subsection {Comparison with Coq's approach}
	
In Coq's latest implementation of a Ring solver, described in [1], they almost followed what has just been desribed as a "traditional" approach with the use of many auxiliary lemmas. The few differences essentially lie in the way the function $reflect$ is defined. In Coq, they use the language LTac to program this automatic reflection\footnote{This function --that they call mkPolexpr-- can be found in $plugins/ring/Ring\_tac.v$}. Ltac is an untyped tactic language. It is untyped in the sense that an Ltac "function" produces something which might not have a valid  --and unique-- type. Because of this, Ltac definitions can only be used in the context of goals. Thus, applying a tactic defined with LTac might work, and then it makes progress to the current goal, or might fail, and in this case the goal in kept unchanged. And anyway, the safety of the proof done is going to be checked during the final QED. So, Ltac functions can't be used in the statement of a lemma, and it is therefore not possible to reason about them. That means that it is not possible to write the lemma $reflect\_and\_reify\_correct$ of the "traditional" approach described in the previous subsection, because it is even impossible to state it as it uses a function defined in LTac. Because they can't even state this property, they can't finish the proof of the main theorem $decideEq\_correct\ :\ \forall\  x\ y:c,\ decideEq\ x\ y\ =\ true\ \rightarrow\ x\ =\ y$. Indeed, the last step of this proof was to apply two times --one for the LHS, one for the RHS-- the fact that $\forall\ x:c,\ reify\ (reflect\ x)\ =\ x$. One possibility would have been to add this axiom, but this is particularly unsightly, and potentially harmful. Also, it would imply that anyone using the ring prover would have this axiom added to his development, and would be forced to believe in it. Some proofs would be done automatically for the user of the system, but at the overly-expensive price of adding some uncertainty.
Instead, what they did for Coq's implementation of the Ring prover is to replace the main theorem $\forall\  x\ y:c,\ decideEq\ x\ y\ =\ true\ \rightarrow\ x\ =\ y$ by the following weaker --but still powerful enough-- lemma\footnote{This lemma --that they call $setpolynomial\_simplify\_ok$ can be found in $plugins/ring/Setoid\_ring\_normalize.v$}  : $f\_correct\ :\ \forall\ (e1\ e2\ :\ Expr),\ beq_{Expr}\ (norm\ e1)\ (norm\ e2)\ =\ true\ \rightarrow\ reify\ e1\ =\ reify\ e2$.
Now, the tactic works like this. When trying to prove the goal $a=b$, it computes $(reflect\ a)$ and $(reflect\ b)$. It then tries to apply $(f\_correct\ (reflect\ a)\ (reflect\ b))$. 
\itemize
\item
If it can unify the goal $a=b$ with $reify\ (reflect\ a)\ =\ reify\ (reflect\ b)$ then it only has to check the validity of the premise by running the decision procedure. More precisely, if $beq_{Expr}\ (norm\ (reflect\ a))\ (norm\ (reflect\ b))$ is evaluated to $true$, then it has built the premise of $f\_correct$ and there's nothing left to prove. However, if the result was false, then it means that the automatic ring prover hasn't been able to prove this goal, because the LHS and RHS don't reduce to the same thing. If this ring prover is complete, it means that $a$ is not\footnote{Note that in this case, it hasn't produced such a formal proof of disequality, which isn't the goal of a ring prover} equal to $b$, or at least, they aren't equal only with the properties of a ring.
\item
if it couldn't unify the goal $a=b$ with $reify\ (reflect\ a)\ =\ reify\ (reflect\ b)$, then it means that there is something wrong in the definitions of the functions $reflect$ and $reify$, and it could print something like "The ring prover has failed unexpectedly. There's something wrong with the implementations of the $reflect$ and $reify$ functions". Nothing really bad happened, as no inconsistent proof has been produced, nor no axioms added. That would just mean that the implementation of the ring prover is slightly broken, and that some goals that should be automatically provable aren't automatically proved. Thus, it would only decrease the completeness of the prover. That would be of course bad --because in the extreme case, the prover never succeed in a generating a proof and is thus completely useless--, but that would only limit the scope of usage of the prover.

	\subsection {Correctness and completeness}

		\subsubsection{Correctness}
		
Idea : obtained by construction. In fact, what we really needed to produce was the proof of equality, and not the normalised terms. The only two things we have to ensure are :
\begin{itemize}
\item not having introduces any axioms
\item not having introduced any non total function (is it really needed in fact if all this stuff only exists at typecheck and not at runtime? I guess it's fine as long as we haven't used non-total functions to illegitimately extract proof of lemmas)
\end{itemize}

If we meet the two conditions above, we simply can't produce a false proof of a statement, because the typechecker would complain. Like in Coq's approach where they just see if the typecheck is ok to apply $f\_correct\ (reflect\ a)\ (reflect\ b)$ in order to prove $a=b$. The typecheck only agrees if $reify\ (reflect\ a) = reify(reflect\ b)$ can be unified with $a=b$, which is the case if the $reify$ and $reflect$ functions have been correctly defined.
		
		\subsubsection{Completeness}
		
Idea 1 : Having a complete tactic is important, because otherwise the tactic is not usable often, and thus is not really valuable. However, having a formal proof of the completeness in the system itself isn't really interesting. As long as we do not meet an equality that should be provable, and which isn't proved by our tactic, there is no problem. And if this situation does happen, nothing really bad really happened : no inconsistencies have been introduced, etc. The tactic just refuses to do it automatically for the programmer. The human can still try to attempt it. \\
\\
Idea 2 : Completeness is not, as one could imagine : \\
$a=b \rightarrow norm\ (reflect\ a) = norm\ (reflect\ b)$
The reason is that we could just rewrite the hypothesis in the goal, without having to inspect the behaviour of the $norm$ function. That would prove nothing interesting.
Completeness is in fact $norm\ (reflect\ a) \neq norm(reflect\ b) \rightarrow a \neq b$, which is in fact :
$decideEq\ (reflect\ a)\ (reflect\ b) = Nothing \rightarrow a \neq b$.
This thing is terrible to prove in the proof assistant. It has never been done for this problem (not for Coq's ring prover, not for Agda ring prover). Can I do it for the little example with natural numbers though ? \\
\\
Idea 3 : We have the guarantee that we aren't losing any totality because of the $reflect$ function because of our index ! This is another extra advantage of our approach. We know that $reify\ (reflect\ a)$ is always unifiable with $a$ in our case. Coq's approach doesn't have this guarantee, and could potentially lose some completeness if this property is not always true.