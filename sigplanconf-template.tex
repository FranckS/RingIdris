%-----------------------------------------------------------------------------
%
%			Edwin's and Franck Paper !
%  uses the template for sigplanconf LaTeX Class
%
%-----------------------------------------------------------------------------


\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\newcommand{\cL}{{\cal L}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{PLPV ’14, Co-located with POPL 2014}{January 21, 2014, San Diego, CA, USA.}
\copyrightyear{2013} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\preprintfooter{My paper for PLPV’14}
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Using dependent types for writting correct by construction tactics}
\subtitle{An exemple for a solver over algebraics structures}

\authorinfo{Edwin Brady\and Franck Slama}
           {University of St Andrews, United-Kingdom}
           {ecb10@st-andrews.ac.uk \and fs39@st-andrews.ac.uk}

\maketitle

\begin{abstract}
In the quest of certified software, at least two main approachs are possible. The usual way is generally to write a program, and then to prove its correctness afterwards. An alternative is to ensure the correction by construction, i.e., by having such precise types that all the properties we want are already ensured. Both approach have their benefits. The usual way is naturally good for dealing with a lot of properties to ensure, one proved after the other, and all are proved after the definition of the function. The correct by construction approach is not so good for dealing with lot of properties to ensure, but one of its merits is that the writing of the program and the proof is simultaneously -forcing the programmer to think about correctness while programming-, and every bit of code has its "proof part", making therefore a strong link between the function and its proof of correctness. If the code of the function changes, that will be much easier to change the correspong bit in the proof. The usual approach usually fails for this purpose, since a script of proof done afterwards in a proof mode is not easy to maintain, mainly because these kind of scripts are not easy to read.
In this paper, we propose to describe as an exemple a correct by construction implementation of a solver of equalities over some algebraic structures (magma, semigroup, monoid, group, ring and commutative ring). This kind of automatic solvers are useful for proof assistants because these proofs of equalities usually consist of a long and not really interesting serie of rewriting. Thanksfully, for each of the algebraics structures we mentionned, there exists a complete and decidable algorithm which determines if a given equality is true, and which constructs a proof of this fact if appropriate. Our approach is to work by reflection -enabling to write the tactic in the language itself-, and to ensure its correness by construction, thanks to our extensively use of dependent types. Also, our approach is fairly  generic and avoid a lot of duplication for the solvers over the different structures. 

%Previous abstract, too much focus on the solver, and not enought on the correct by construction part, wich is our contribution

%In the quest of certified sofware, one problem still remains: how can we make the process of proving easier? Some auxiliary proofs can be long and are not part of the interesting bit. For these cases, we would like to be able to let the machine find the proof for us. In this paper  we focus on a specific kind of  proofs : proofs of equalities over groups and rings. For this kind of structures, there exists a complete and decidable algorithm which determines if a given equality is true, and constructs a proof of this fact if so. However, since we want the tactic to be safe, we need to produce a proof of correction of this implementation. In our approach, this proof is obtained for free, because the tactic is built correct by construction, thanks to our extensive use of dependent types. Our approach is to work by reflection, and to normalize both side of the equality with a serie of rewritings that uses the axioms of the algebraic structures. At every step of the rewriting, a proof of equality between the new and the preivous terms is generated. Our approach is also generic, since it works for groups or ring, whether or not commutative. This example shows that the use of dependent types can help building software correct by construction.
\end{abstract}

\category{F.4.1}{Mathematical logic and formal languages}
			{Mathematical logic}
			[Proof theory]
\category{F.3.1}{Logics and meanings of programs}
			{Specifying and Verifying and Reasoning about Programs}
			[Mechanical verification]
\category{D.3.3}{Programming Languages}
			{Language Constructs and Features}
			[Abstract data types]


% general terms are not compulsory anymore, 
% you may leave them out
\terms
Languages, Verification

\keywords
dependent types, proof automation, reflection

\section{Introduction}

As soon as we start to work with numbers on a proof assistant, we are facing the need to prove that a certain term is equal to another. Of course, they are usually not syntactically equal -this case would be trivial-, but they are equal according to a set of properties. These properties are either obtained by implementation (the implementation of + for relatives numbers is symmetric for exemple), or by axioms if we are working with an abstract structure.
These proofs of equality are usually done by hand, and are made with a potentially long serie of rewriting, using the available properties that we have. For exemple, if x and y are relatives numbers, and if we want to show that :
(x + y) * z = (z * x) = (y * z), we can first use the fact the symmetry of *, saying that
for all a b, a * b = b * c
With the use of this property, we can rewrite the left part into the term z * (x + y).
If now we use the distributivity of * on +, which says that :
forall a b c, a * (b+c) = a*b + a*c,
we now obtain the term x*z + y*z for the left side.
If we use again the symmetry of * on the subterm (x*z), the left side of the equality becomes : z*x + y*z, which is what we want.

This kind of proofs therefore consists of a potentially long serie of rewriting, every rewriting step using one property of the theory. Without some specific automation, this serie of rewriting is done by the user of the proof assistant. This is time consuming, and a little change in the left or the right hand side of the equality can invalidate completely the proof. The reusability of this kind of proofs is indeed very low, since they are performing rewritings for a very specific term. In this paper, we describe a certified implementation of a solver for algebraics structures, for the Idris language. Idris is a relatively new purely functional programming language with full dependent types. Idris also supports tactic based proofs. 

For our goal, we focus on some specific theories, which are the folowing algebraics structures : magmas, semi-group, monoid, group, abelian group, ring and commutative ring.
For these structures, this is effectively possible to decide if a given equality is true, and to produce the proof of the equality. This result comes directly from the fact that there exist a normal form for every element of these structures. The general idea is therefore to normalize both side of the equality, and then to compare them using the usual syntactical Leibniz's equality.
This approach was followed by [paper Coq ring] for implementing a ring solver for the Coq proof assistant.
Our contribution mainly consits of two parts :
	- We follow a "correct by construction" approach for implementing the reduction procedures, instead of implementing a normalization procudure, and proving afterwards that this function effectively computes a normal form. For achieving this goal, we are extensively using dependent types in order to capture the interesting properties that matters. 
	- We try to be as general generic as possible, and re-use as much as possible the code of normalization from the strucures below in the upper structures. For exemple developping an expression by using the axiom of distribituvty works exactly the same in a commutative ring and in a ring.

\section{A brief overview of Idris}
Idris is a purely functional 


Idris is a purely funcitonal programming language fairly recent. Its main purpose is to bring formal certification into the scope of programming : instead of Coq or Isabelle, Idris is not desegned as a proof asssiant, but has a real programming language. One of its more interesting features -and the one that enables to effectively manipulate logical statments and proofs in the language- is its full and effective support for dependent types. Especially, Idris has a particularly good dependent pattern maching, which is something mandatory for writting code correct by construction.




\section{Normalization and polynomials in normal form}
% Ici on donne l'idée générale. Nom de la section peut etre à revoir
Lots of text.

More text.

\section{Datatypes}

Lots of text.

\subsection{Hierarchy of algebraic theorys}

Lots of text.

The exemple with Nat is a monoid

More text.

\subsection{Reflection in an abstract syntax}

Lots of text.

More text. 

\section{Normalization procedures}

\subsection{Normalization for terms in a magma}

\subsection{Normalization for terms in a semi-group}

\subsection{Normalization for terms in a monoid}

\subsection{Normalization for terms in a group}

\subsection{Normalization for terms in a ring}

\subsection{Normalization for terms in a commutative ring}

\section{Coating}
%enrobage

\section{Metaification}

\section{Conclusion}

\section{References}






Lots of text.

More text.


Lots of text.

More text.

Lots of text.

More text.


Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.


Lots of text.

More text.

Lots of text.

More text.


Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.


Lots of text.

More text.

Lots of text.

More text.




Lots of text.

More text.

Lots of text.

More text.

Lots of text.


Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

More text.

Lots of text.

\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

\begin{thebibliography}{}
\softraggedright

\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
P. Q. Smith, and X. Y. Jones. ...reference text...

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

