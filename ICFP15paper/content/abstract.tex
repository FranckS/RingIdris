
\begin{abstract}

We present a collection of reflective and correct by construction tactics for automatically proving equalities in different algebraic structures in the dependently typed
programming language Idris.
The distinctive feature of this correct by construction approach is that it makes a
strong link between the implementation of the tactic and its proof of correctness,
thereby enhancing the re-usability and the readability of the proof.
This example shows that the use of dependent types can be of great value for
building correct by construction software, since dependent types enable to capture
logical properties easily. Our approach is also generic in order to avoid code
duplication for the different algebraic structures : we are building a hierarchy of tactics where each tactic uses the others from the above levels.

%Before Edwin's help :

%We present a collection of reflective and correct by construction tactics for solving equalities in different algebraic structures for the Idris language. The main interest of this correct by construction approach is to make a strong link between the implementation of the tactic and its proof of correctness, thereby enhancing the re-usability and the readability of the proof, unlike the inflexible usual way which consists in programming and later proving the correctness. This example shows that a the use of dependent types can be of great value for building correct by construction software, since dependent types enable to capture easily logical properties. Our approach is also fairly generic in order to avoid code duplication for the different algebraic structures.

% My second abstract, still to verbose

%In the quest of certified software, at least two main approachs are possible. The usual way is generally to write a program, and then to prove its correctness afterwards. An alternative is to ensure the correction by construction, i.e., by having such precise types that all the properties we want are already ensured. Both approachs have their benefits. The usual way is naturally good for dealing with a lot of properties to ensure, one proved after the other, and all are proved after the definition of the function. The correct by construction approach is not so good for dealing with lot of properties to ensure, but one of its merits is that the writing of the program and the proof is simultaneously -forcing the programmer to think about correctness while programming-, and every bit of code has its "proof part", making therefore a strong link between the function and its proof of correctness. If the code of the function changes, that will be much easier to change the correspong bit in the proof. The usual approach usually fails for this purpose, since a script of proof done afterwards in a proof mode is not easy to maintain, mainly because these kind of scripts are not easy to read.
%In this paper, we propose to describe as an exemple a correct by construction implementation of a solver of equalities over some algebraic structures (magma, semigroup, monoid, group, ring and commutative ring). This kind of automatic solvers are useful for proof assistants because these proofs of equalities usually consist of a long and not really interesting serie of rewriting. Thanksfully, for each of the algebraics structures we mentionned, there exists a complete and decidable algorithm which determines if a given equality is true, and which constructs a proof of this fact if appropriate. Our approach is to work by reflection -enabling to write the tactic in the language itself-, and to ensure its correness by construction, thanks to our extensively use of dependent types. Also, our approach is fairly  generic and avoid a lot of duplication for the solvers over the different structures. 

%Previous abstract, too much focus on the solver, and not enought on the correct by construction part, wich is our contribution

%In the quest of certified sofware, one problem still remains: how can we make the process of proving easier? Some auxiliary proofs can be long and are not part of the interesting bit. For these cases, we would like to be able to let the machine find the proof for us. In this paper  we focus on a specific kind of  proofs : proofs of equalities over groups and rings. For this kind of structures, there exists a complete and decidable algorithm which determines if a given equality is true, and constructs a proof of this fact if so. However, since we want the tactic to be safe, we need to produce a proof of correction of this implementation. In our approach, this proof is obtained for free, because the tactic is built correct by construction, thanks to our extensive use of dependent types. Our approach is to work by reflection, and to normalize both side of the equality with a serie of rewritings that uses the axioms of the algebraic structures. At every step of the rewriting, a proof of equality between the new and the preivous terms is generated. Our approach is also generic, since it works for groups or ring, whether or not commutative. This example shows that the use of dependent types can help building software correct by construction.
\end{abstract}

\category{F.4.1}{Mathematical logic and formal languages}
			{Mathematical logic}
			[Proof theory]
\category{F.3.1}{Logics and meanings of programs}
			{Specifying and Verifying and Reasoning about Programs}
			[Mechanical verification]
\category{D.3.3}{Programming Languages}
			{Language Constructs and Features}
			[Abstract data types]


% general terms are not compulsory anymore, 
% you may leave them out
\terms
Languages, Verification

\keywords
dependent types, proof automation, reflection
