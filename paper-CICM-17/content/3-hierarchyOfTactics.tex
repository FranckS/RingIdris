\section{A hierarchy of tactics}

In this section, we want to prove equalities not only for $Nat$ but for various datatypes, and for various properties. With some abstraction, we can solve the problem of generating proof of equality for many datatypes like natural numbers, lists, matrix, and many others \emph{all at once} by implementing a very generic prover that works for any type that is an instance of an algebraic structure. In fact, that will be a hierarchy of provers --with one prover for each algebraic structure-- that can prove equalities of terms in any instance of the corresponding structure. We will no longer only work with the properties of associativity and of right neutral element for natural numbers as it was the case in the previous section, but we will have available the properties of a given algebraic structure. These tactics will be usable on any type that satisfies these properties. The properties of a given algebraic algebraic structure will be expressed in a corresponding interface. This interface will extend the interface from which it naturally inherits. For example, the $Group$ interface will extend the $Monoid$ one. We will end up with a hierarchy of interfaces and will write one tactic for each of these interface. All the tactics that we will implement (the ring prover, the group prover, etc) will be able to work on any type, being given that an implementation of the corresponding interface is provided.

	\subsection{Proving equivalences instead of equalities}
	
With some reasonable additional effort, we could produce a collection of tactics for proving equivalences instead of only equality. The machinery would be very similar, and if we do the right abstraction from the start, we could gain one more degree of genericity, with the freedom of choosing the equivalence relation (which can of course be the usual equality). We want to give to the user the possibility to define his own equivalence notion, as long as he's able to provide the properties of the algebraic structure he wants to use. Let's call $c$ the \emph{carrier} type, ie, the type on which we want to prove equivalences. The equivalence relation on $c$ has the following profile $(\simeq) : c \rightarrow c \rightarrow Type$\footnote{This 'Type' would be a 'Prop' in systems --like Coq-- that make a distinction between the world of computations and the world of logical statements}, and has to be accompanied by the usual properties of reflexivity, symmetry and transitivity.

All of our tactics will require to have a way of testing this equivalence between elements of the underlying set, that is to say, a way to test equivalence between constants. For this reason, we define a notion of Set\footnote{This notion of Set isn't a formalisation of sets and their elements, but is only a way to talk about the carrier type and an equivalence relation, sometimes called Setoid}, which only requires the definition of the equivalence relation --accompanied with the proofs that this is indeed an equivalence relation-- and this equivalence test $set\_eq$. All the algebraic structures will later extend this interface :

\begin{figure}[H]
\begin{center}
\begin{lstlisting}
interface Set c where
    ($\simeq$) : c $\rightarrow$ c $\rightarrow$ Type

    refl : (x:c) $\rightarrow$ x $\simeq$ x
    sym : {x:c} $\rightarrow$ {y:c} $\rightarrow$ (x $\simeq$ y) $\rightarrow$ (y $\simeq$ x)
    trans : {x:c} $\rightarrow$ {y:c} $\rightarrow$ {z:c} 
            $\rightarrow$ (x $\simeq$ y) $\rightarrow$ (y $\simeq$ z) $\rightarrow$ (x $\simeq$ z)    
    
    set_eq : (x:c) $\rightarrow$ (y:c) $\rightarrow$ Maybe (x $\simeq$ y)
\end{lstlisting}
\end{center}
\caption{Set}
\label{Set}
\end{figure}
If the user wants to prove propositional equalities, then he will simply instantiate $(\simeq)$ with the built-in $(=)$ during the definition of the $Set$ implementation.
Note that $(\simeq)$ is only weakly decidable in the sense that $set\_eq$ only produces a proof when the two elements are equivalent, but it doesn't produce a proof of dis-equivalence when they are different -- instead, it simply produces the value $Nothing$--. That's natural, as we want to generate proof of equivalence, and not to generate counter examples for proving dis-equivalence, which is another problem.

Obviously, there is no tactic associated to $Set$, since we have no operations and no properties associated to this structure. Therefore, equivalences in a $Set$ are just the "syntactic equivalences", and they can simply be proven with $refl$\footnote{$refl$ should not be confused with $Refl$, the only constructor of $=$. But of course, when $(\simeq)$ is instantiated with the equality $=$, the instantiation of $refl$ will be $Refl$. Therefore, $refl$ of the interface $Set$ is a generalisation of the most specialised $Refl$ for $=$}.

As it was the case in section~\ref{sect:aSimpleProofAutomation}, the kernel of our machinery will be a function $reduce$ that will be composed of multiples functions composed together, that each do a part of the normalisation and that generate the proof of equivalence between old and new concrete values for this part of the normalisation. That was the two functions $expr\_l$ and $l\_expr$ on the smaller problem presented in chapter~\ref{sect:aSimpleProofAutomation}.

Working with equivalences instead of equalities will bring one complication. These proofs of correctness that we will have to produce by hand will be slightly more complicated, as we won't be able to use idris' "rewrite" command, that enables to rewrite a subterm of a term by another one, provided that the two subterms are equal. More precisely, if we need to prove $P\ x$, and have a proof of equivalence $pr:x \simeq x'$, we can't use "rewrite pr" in order to transform the goal into $P\ x'$, as we would normally do if the available proof would be an equality $x=x'$. This is a classical problem of working within a setoid, and this problem can be slightly mitigated when the programming language offers a good support for rewriting terms in setoids. However, Idris isn't equipped with any automation for setoids, ans everything will have to be done by hand. For this purpose, we will use the following lemma :

$eq\_preserves\_eq : \{c:Type\} \rightarrow (Set\ c) \rightarrow (x:c) \rightarrow (y:c) \rightarrow (c1:c) \rightarrow (c2:c) \rightarrow (x \simeq c1) \rightarrow (y \simeq c2) \rightarrow (c1 \simeq c2) \rightarrow (x \simeq y)$.

This lemma says that the equivalence preserves the equivalence, which means that in order to prove $x \simeq y$, we can prove the (hopefully) simplest problem $c1 \simeq c2$, provided that $x \simeq c1$ and that $y \simeq c2$. This lemma will be intensively used for building the proofs of equivalence (between the old and new indices) that are required by the development of our machinery.

\begin{proof}
We have $x \simeq c1$ and we have $c1 \simeq c2$, therefore we have $x \simeq c2$ by the use of the axiom of transitivity (of the interface $Set$). \

We also have $y \simeq c2$ and therefore we have $c2 \simeq y$ by the use of the symmetry axiom (of the interface $Set$). \

Now that we have these fresh proofs of $x \simeq c2$ and of $c2 \simeq y$, we can use one last time the property of transitivity, in order to get a proof of $x \simeq y$.

\end{proof}

This lemma will be basically used as a replacement to the "rewrite" tactic that we can no longer use since we are dealing with equivalence and not equality.

		\subsection{Hierarchy of interfaces}

Each interface will contain the axioms of the corresponding abstract structure. The first structure, completely trivial, is the magma. A magma is a structure built on top of $Set$, that just adds a $Plus$ operation, and no specific properties about it :

\begin{lstlisting}
interface Set c => Magma c where
    Plus : c $\rightarrow$ c $\rightarrow$ c
\end{lstlisting}

This code means that a type $c$ (for $carrier$) is a Magma if it is already a Set (ie, it is equipped with the equivalence relation $\simeq$ and the test $set\_eq$), and if it has a $Plus$ operation.
In fact, there is an additional requirement that will apply for all operators (in this case, the Plus operation), which is that they need to be "compatible" with the equivalence relation, which is expressed by the following axiom for $Plus$ : \\ $Plus\_preserves\_equiv : \{c1:c\} \rightarrow \{c2:c\} \rightarrow \{c1':c\} \rightarrow \{c2':c\} \rightarrow (c1 \simeq c1') \rightarrow (c2 \simeq c2') \rightarrow ((Plus\ c1\ c2) \simeq (Plus\ c1'\ c2'))$ \\ 
This requirement comes from the fact that we're dealing with any equivalence relation. The user is free to use his own equivalence relation, but it should be compatible with the operations that he is using.
As it was the case for $Set$, there is no tactic to write for $Magma$, because there is no property at all : all equivalences are again syntactic equivalences, and they can all be proven by $refl$\footnote{$refl$ should not be confused with $Refl$, the only constructor of $=$. But of course, when $(\simeq)$ is instantiated with the equality $=$, the instantiation of $refl$ will be $Refl$. Therefore, $refl$ of the interface $Set$ is a generalisation of the most specialised $Refl$ for $=$}. 

A semi-group is a magma (ie, it still has a $Plus$ operation), but moreover it has the property of associativity for this operation. 

\begin{lstlisting}
interface Magma c => SemiGroup c where
    Plus_assoc : (c1:c) $\rightarrow$ (c2:c) $\rightarrow$ (c3:c) 
               $\rightarrow$ (Plus (Plus c1 c2) c3 $\simeq$ Plus c1 (Plus c2 c3))
\end{lstlisting}

The Monoid structure is a Semi-Group with the property of neutral element for a distinguished element called $Zero$.

\begin{lstlisting}
interface SemiGroup c => Monoid c where
    Zero : c    
    Plus_neutral_1 : (c1:c) $\rightarrow$ (Plus Zero c1 $\simeq$ c1)    
    Plus_neutral_2 : (c1:c) $\rightarrow$ (Plus c1 Zero $\simeq$ c1)
\end{lstlisting}

The hierarchy of interfaces continues with Commutative-Monoid, Group, Commutative Group, Semi-Ring, Ring, but we only show Group for reasons of space :

\begin{lstlisting}
interface Monoid c => Group c where
    Minus : c $\rightarrow$ c $\rightarrow$ c
    Neg : c $\rightarrow$ c
    Minus_simpl : (c1:c) $\rightarrow$ (c2:c) $\rightarrow$ Minus c1 c2 $\simeq$ Plus c1 (Neg c2) 
    Plus_inverse : (c1:c) $\rightarrow$ (Plus c1 (Neg c1) $\simeq$ Zero, Plus (Neg c1) c1 $\simeq$ Zero)
\end{lstlisting}

As discussed on the smaller problem, the algorithm of normalisation will not directly use the concrete values of type $c$, but reflected terms instead, indexed over the concrete values. That still holds here.
