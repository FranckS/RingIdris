\section{Related work}
\label{sect:relatedWork}

As mentioned, Coq's implementation of a ring prover~\cite{Coq2005} was also using proof-by-reflection techniques, but without the guarantees obtained with our type-safe reflection mechanism, and without the correct-by-construction approach : they have first defined the normalisation of terms, and afterwards they've proven the correctness of the normalisation with the external lemma :
$\forall\ (e1\ e2\ :\ \code{Expr}),\ beq_{Expr}\ (\code{norm}\ e1)\ (\code{norm}\ e2)\ =\ true\ \rightarrow\ \code{reify}\ e1\ \simeq\ \code{reify}\ e2$ which therefore needs a \code{reify} function that we do not need in our development. Another difference is that Coq's prover only deals with rings and semi-rings (commutative or not), but not with any of the intermediate structures (semi-group, monoid, group, etc), unlike us. However, their implementation has better performances due to the use of sparse normal form and more optimised algorithms.
Our automatic reflection was written with Idris reflection mechanism which allows to do pattern matching on syntax, and their automatic reflection is programmed in Ltac~\cite{DelahayeLTac} : a proof dedicated and untyped meta-language for the writing of automations. \\

Proof automations have been investigated for various proof assistants and programming languages. In Coq, appart from the ring prover, there's also the omega solver~\cite{Cregut04}, which solves a goal in Presburger arithmetic (i.e. a universally quantified formula made of equations and inequations), and a field~\cite{DelahayeField} decision procedure for real numbers, which plugs to Coq's ring prover after simplification of the multiplicative inverses. Various automations have also been done in Agda~\cite{DBLP:conf/mpc/KokkeS15} ~\cite{Lindblad04}. \\

Proofs by reflection has been intensively studied as in~\cite{ChlipalaBook} and~\cite{Malecha14}, but without anything similar to the type-safe reflection that we have presented here. \\

Finally, when we leave the ground of nice mathematical structures like groups, rings and fields, one can decide to work with arbitrary rewriting rules, but in the general case there isn't a complete decision procedure for such problems, because there is usually no normal form. This is where deduction modulo~\cite{Dowek03} ~\cite{DelahayeModulo} and heuristics for proof search starts. \\


