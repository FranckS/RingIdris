-- Edwin Brady, Franck Slama
-- University of St Andrews
-- File README
-- Brief description of what this stuff is
---------------------------------------------------

Current version is Version 0.6 (05/06/2016)


Summary :
---------

This is the implementation of a collection of tactics for Idris, in Idris.

Note that this work is still in progress, so you should not (yet) use it now, as the final version 
might not be compatible with the current state that you see now.

We will explicitely mention when we consider to have something reliable and usable for real projects.
At the moment, you should use this collection of tactics for testing purpose only. 

If you wish to give a feedback, don't forget, that THIS IS STILL WORK IN PROGRESS. 
There may be bugs, the code is far from being cleaned (this is research code after all!), etc. 


News :
------------------------------

New with version 0.6 : Compiles with Idris 0.11 (released on March 2016)
						+ Automatic reflection in progress (but problems with Idris)

____________________


New with version 0.5 : Compiles with Idris 0.9.15.1 amongst other things

____________________


New with version 0.4: Each prover can now deal with any equivalence relation, instead of just the propositional equality.

____________________


Current state (05/06/2016) : 
------------------------------

There are a few axioms to prove and Meta-variables to solve :
Some of them are because of a new treatment added in Ring (and these proofs are easy to do, but boring)
Some others are for the automatic reflection mechanism (and some are a bit annoying to do without using proof irrelevance)

- 1) Magma prover WORKS

- 2) Semi-group prover WORKS
However, one remark :
   . We don't pass the totality checker at the moment

- 3) Monoid prover WORKS
However, one remark :
   . We don't pass the totality checker at the moment
   
- 4) Commutative Monoid prover WORKS  [Added with version 0.3] 
However, one remark :
   . We don't pass the totality checker at the moment

- 5) Group prover WORKS
However, one remark :
   . We don't pass the totality checker at the moment

- 6) Commutative Group (=Abelian group) prover WORKS
However, one remark :
   . We don't pass the totality checker at the moment

- 7) Ring prover : WORKS
However, one remark :
   . We don't pass the totality checker at the moment

- Commutative Ring prover NOT YET IMPLEMENTED

How to load and typecheck the tactics :
----------------------------------------
Simply do :

idris main.idr -p contrib

That will load and typecheck the 7 tactics that are implemented at the moment + the tests (which includes instances of the corresponding typeclass) for each of them.

How to use it :
----------------

- An automatic metaification (or reflexion) mechanism is currently being implemented. But at the moment, you still have to encode by hand the two sides of the 
equality you wish to prove. Yes, it can be overwhelming... :-(

You can have a look at the test files commutativeGroup_test.idr and group_test.idr (and the other test files) for some detailed examples.


A fairly big example
---------------------

Can be found in the file binary.idr.
Simply run : 

idris ./Provers/binary.idr -p contrib

That will compile the tactics and that will generate the proof required (in the term goal_aux).

To see the proof generated, simply ask for the evaluation of :

\l,c,bit0,bit1,x,x1,v,v1,known => goal_aux l c bit0 bit1 x x1 v v1 known

Note that because the automatic reflexion is still under development, this file is an horrific monster.
It might become nicer at some point. Or it might not.

About the technique :
----------------------

0) Note that in this stuff, we are interested in the proof of correctness 
(which is precisely the proof of equality/equivalence that we want) and not (really) by the algorithms implemented
(which are normalizations of terms, in different algebraic structures).

1) We follow a "correct by construction" approach : rather than implementing
the normalization of terms and afterwards proving that a normalized term
and the original term denote the same value, we do it "bit by bit" : we 
construct this proof at the same time as we normalize the two terms.
The result if that the proof of correctness (which is in what we are interested)
is a lot easier to do : for each little step of rewriting, the proof is quite 
trivial.

2) We work by reflection in the langage itself (Idris), rather than implementing
each tactic in the host language (Haskell). That's something nice, especially
for a future bootstrapping of Idris.

3) Each prover uses the algebraic provers of the structures underneath : we 
do *not* copy and paste identic treatments at different levels : we convert our 
terms between different structures, and we reuse every bits possible.
For exemple, dealing with neutral elements (which appears for the first time at
the Monoid level) is NOT re-implemented in the structures above (ie, Group, CommutativeGroup, etc).
Instead, the Group prover converts the terms, and calls the Monoid prover. 
Some clever encodings had to be developped for doing some of these conversions 
(when we convert to a structure which is less expressive than the initial structure,
as it is the case when converting from a ring to a commutative group).

About correctness and completeness :
----------------------------------

1) Correctness
As mentioned, the proof of correctness if in fact what we want to obtain.

Let's assume that all our methods are total (even though a few of them are not
provably total in Idris *yet* : mainly because of some non-structural 
recursions for which we will have to manually encode the termination criteria).
Thus, because we don't have any axiom nor meta-variable to solve, we can be 
entirely sure that the proof generated is always a valid proof, assuming you
trust the Idris kernel (and if you don't, there's anyway no point trying to prove 
stuff in it).
That means that if the prover tells you that A = B (and gives you a proof of it),
you can be sure that indeed A = B (maybe because of your axioms, or because of
your implementation of your structure and operations).

2) Completeness

The tactic is expected to be complete, which means that when trying to prove A=B
if the tactic fails, then it means that A and B are not equal.
However, we do not have a formal proof of this in the system itself, which would
be hard to build, and which would not really bring any interesting guarantee.

 