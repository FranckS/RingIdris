
\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}

\usepackage{url}
  
  
\usepackage{listings} 

\lstset{
  basicstyle=\ttfamily,
  columns=fullflexible,
  keepspaces=true,
  mathescape
}

  
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Short paper : Automatic predicate testing in formal certification}
\subtitle{You've only proven what you've said, not what you meant!}

% a short form should be given in case it is too long for the running head
%\titlerunning{Automatic predicate testing in formal certification}


\author{Franck Slama\\
         \email{fs39@st-andrews.ac.uk}}

\institute{University of St Andrews, United Kingdom}

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
The use of formal methods and proof assistants helps to increase the confidence in critical software. However, a formal proof is only a guarantee relative to a formal specification, and not necessary about the real requirements. There is always a jump when going from an informal specification to a formal specification expressed in a logical theory. Thus, proving the correctness of a piece of software always makes the implicit assumption that there is adequacy between the formalised specification --written with logical statements and predicates-- and the real requirements --often written in english--. Unfortunately, a huge part of the complexity lies precisely in the specification itself, and it is far from obvious that the formal specification says exactly and completely what it should say. Why should we trust more these predicates than the code that we've first refused to trust blindly, leading to these proofs? We show in this paper that the proving activity has not replaced the testing activity but has only changed the object which requires to be tested. Instead of testing code, we now need to test predicates. We present recent ideas about how to conduct these tests inside the proof assistant on a few examples, and how to automate them as far as possible.

\keywords{Formal certification, predicate testing, proof assistant}
\end{abstract}


\input{./content/1-introduction.tex}


\input{./content/2-specCanGoWrong.tex}


\input{./content/3-testingInside.tex}


\input{./content/4-differentKindOfProperties.tex}


\input{./content/5-conclusion.tex}



\bibliographystyle{splncs03}

\nocite{DeMillo1979}

\bibliography{bib-TAP}

\end{document}
