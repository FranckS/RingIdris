\section{Testing the predicate by automatic generation of terms}

\label{sect:testingInside}

The key idea that this paper wants to convey is that it is often easier to generate examples of a notion than it is to precisely define it. We can operate an interesting change of point of view by generating the set of terms that we precisely wanted to describe with the predicate. With our example of sorted lists, that means that we need to define the same notion of being sorted, but this time with a definition example-based. Writing a function that produces all the sorted lists might be a bit more difficult than just giving a few examples, but this complicated function will have the main advantage of being so different from the predicate that if the two notions agree, then we will have gained a great confidence on the predicate. We decide to use coinduction and the type Stream (a coinductive version of lists, potentially infinite) in order to generate --with what we call a generator-- all the sorted lists of size $n$.

$generateSortedList : (T:Type)\ \rightarrow\ (recEnu:RecursivelyEnumerable\ T) \rightarrow\ (Tord : Order\ T) \rightarrow\ (n:Nat) \rightarrow Stream\ (List\ T)$.

To do so, the type $T$ needs to be $RecursivelyEnumerable$, which means that there should exists a computational map $Nat\ \rightarrow\ Maybe\ c$ with the condition that this map is surjective, which means that all value of type $c$ should be hit at least once by the map : $map\_is\_surjective : (y:c)\ \rightarrow\ (x:Nat\ **\ (computableMap\ x\ =\ Just\ y))$.

We want to check that this function and the predicate coincide. Since the predicate $isSorted$ is decidable with $decideIsSorted$, we can automatically check whether the generated sorted lists of size $n$ are automatically sorted (according to $isSorted$) by running the decision procedure. But since there can be infinitely many generated sorted lists of size $n$ when $n > 0$, we will only check that the generator and the predicate coincide on a finite observation\footnote{A finite observation of a stream, also called approximation at rank $m$ of a stream, is a vector of size $m$ that has the same $m$ first elements than the stream} of the resulting stream. The key point is that this observation can be arbitrary big, and the bigger it is, the better the guarantee is about $isSorted$.

We show how the observation is made on an example. Let $T$ be a type that only contains three constant values $A$, $B$ and $C$. Since $T$ is finite, it is therefore obviously recursively enumerable. We define on it the strict order $A < B < C$.
Let's automatically generate the first $m$ sorted lists of $T$, of size $n$, by unfolding $m$ times the result of $generateSortedList$.


\begin{lstlisting}
testGenSorted : (m:Nat) -> (n:Nat) -> Maybe(Vect m (List T))
testGenSorted m n = let x = generateSortedList T TisRecEnu TisOrdered n 
                        in unfold_n_times x m
\end{lstlisting}
We can ask for the first 8 sorted lists of size 5 by evaluating $testGenSorted\ 8\ 5$:

\begin{lstlisting}
Just [[A, A, A, A], [A, A, A, B], [A, A, A, C], [A, A, B, B],
      [A, A, B, C], [A, A, C, C], [A, B, B, B], [A, B, B, C]] : Maybe (Vect 8 (List T))
\end{lstlisting}
Now, instead of simply generating the first $m$ sorted lists, we run the decision procedure on all of these $m$ tests in order to know if the predicate and the generator agree on this portion. The result will be a vector $m$ booleans.

\begin{lstlisting}
testSorted : (m:Nat) -> (n:Nat) -> Vect m Bool
testSorted m n = 
  let x = generateSortedList T TisRecEnu TisOrdered n in
    let y = Smap (\l => let res = decideIsSorted TisOrdered l in
			    case res of
			      Yes _ => True
			      No _ => False) x in
	unfold_n_times_with_padding y m True
\end{lstlisting}
And we can inspect the result of running the first 8 tests by evaluating $testSorted\ 8\ 5$.

\begin{lstlisting}
[True, True, True, True, True, True, True, True] : Vect 8 Bool
\end{lstlisting}

However, if the predicate $isSorted$ has been incorrectly written, for example with the broken condition $(h1 \leq h1)$ instead of $(h1 \leq h2)$ in its third constructor $consSorted$, then the result of this test will be :

\begin{lstlisting}
[True, True, True, True, True, True, True, True] : Vect 8 Bool
\end{lstlisting}

When we want to test $isSorted$ on a big number of tests, we might not want to inspect manually the result of each test. We can write a function $testSorted\_result : (m:Nat)\ \rightarrow\ (n:Nat)\ \rightarrow\ Bool$ that calls $testSorted$ and does the boolean $And$ on each element of the resulting vector. Now, we can for example test the predicate on the first 50 sorted lists of size 8 by running $testSorted\_result\ 50\ 8$ and if we do so we get the overall result $True$ which means that the predicate agrees with the generator on all these 50 tests.


