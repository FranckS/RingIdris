\section{Testing the predicate by automatic generation of terms}

\label{sect:testingInside}


It is often easier to generate examples of something than it is to precisely define it. We could operate an interesting change of point of view by generating the set of terms that we precisely wanted to describe with the predicate. With our example of sorted lists, that means that we could try to define the same notion of being sorted, but this time with a definition example-based. Writing a function that produces all the sorted lists might be a bit more difficult than just giving a few examples, but this complicated function will have the main advantage of being so different to the predicate that if the two notions agree, then we will know we've gained a great confidence on the predicate.

We decide to use coinduction and the type LList (which stands for ``Lazy List", that's a coinductive version of lists, potentially infinite) in order to generate all the sorted lists of size $n$.

$generateSortedList : (T:Type)\ \rightarrow\ (recEnu:RecursivelyEnumerable\ T) \rightarrow\ (Tord : PartialOrder\ T) \rightarrow\ (n:Nat) \rightarrow LList (List T)$.

To do so, the type $T$ needs to be $RecursivelyEnumerable$, which means that there should there should exists a computational map $Nat\ \rightarrow\ Maybe\ c$ with the condition that this map is surjective, which means that all value of type $c$ should be hit at least once by the map : $map\_is\_surjective : (y:c)\ \rightarrow\ (x:Nat\ **\ (computableMap\ x\ =\ Just\ y))$.

We want to check that this function and the predicate agree, which means that any list generated by $generateSortedList$ should be a yes instance of the predicate $isSorted$, and reciprocally.

Since the predicate $isSorted$ is decidable with $decideIsSorted$, we can automatically check whether the generated sorted list of size $n$ are automatically sorted or not by running the decision procedure. But since there can be an infinite amount of generated sorted lists of size $n$ when $n > 0$, we will only check that the generative function and the predicate coincide on a finite unfolding of the resulting lazy list.







in order to ensure that the predicate captures the notion that we want for \emph{any} term, we write a function that will 




- it is often easier to generate things rather than to characterise them 
[a quarter of a page : from 3.00 to 3.15

- New : a very nice aspect is that we can now automatically generate \emph{all} the terms that satisfy the predicate. it is therefore possible to see some specific terms and to check weather they should have been captures or not.

- testing the structural properties by automatic generation of the terms that should satisfy them, and running a decision procedure on them.
[half a page : from 3.15 to 3.45]

- Going a step further : ``test automation by proof", which automatises all of them at once, by doing (another) formal proof, which shows that there is equivalence between all the terms generated and the original predicate that we wanted to certify correct according to the original specification.
[half a page : from 3.45 to 4.15]