\section{Conclusions and future work}


We've presented a new way to test a predicate based on an automatic generation of terms that should have the desired property. This adequacy between the predicate and the generator helps to gain confidence in the predicate. The technique presented on section \ref{sect:testingInside} was based on a finite observation of the infinite quantity of generated terms processed by a decision procedure. We've also shown on an example how these tests can be completely automated. In section \ref{sect:aStepForward} we've presented ideas for going a step forward and replacing these tests on the predicate by some new proofs. These new proofs have the advantage of not requiring the predicate to be decidable. However, they imply that we have to trust these new specifications, which are this time about the predicate itself.

We haven't been able to find much work done in the direction of predicate testing in the environment of proof assistants, but we strongly believe that this aspect is crucial, as there is absolutely no point to prove the correctness of a function relatively to a bad specification. One could however question why formal certification is needed at all, if after going through all the effort of interactive theorem proving we still have to test the specification itself and need tools to support it. We believe that the process of formalisation precisely helps to uncover things that were missing or weakly specified in the informal requirements. For example, the development of the formally verified compiler CompCert~\cite{Krebbers2014} has contributed to brought to light many under-specified behaviours in the specification of the C standard.

A natural extension of the work presented here is to study how proof assistants themselves could help to gain confidence about predicates and logical formulae. One possible way could be to see how proof assistants could be equipped with an execution engine for formal specifications, that would replace the very specific machinery that we've showed in the running example of this paper. Another possibility, which in fact complements the first, is to have the proof assistant providing many robust and generic concepts once and for all (like the predicate being sorted), because that would save the user from the error prone activity of writing many primitive logical properties. Equipping proof assistants with many generic and useful concepts already available, like bricks ready to be assembled, is one of the current challenge to make proofs assistants really usable.