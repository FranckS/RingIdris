\section{Replacing tests on the predicate by proofs}

\label{sect:aStepForward}

In order to go a step forward, we can decide to replace the tests on the predicate by proofs. Instead of testing the predicate on a finite subset of all the generated sorted lists, as we did in the previous section, we can try to prove that any of the automatically generated sorted list is provably sorted according to $isSorted$.

\begin{lstlisting}
generated_implies_pred_holds : {T:Type} 
   -> (recEnu:RecEnum T) -> (Tord : Order T) -> (n:Nat) 
   -> (All (generateSortedList T recEnu Tord n) 
           (\l => isSorted Tord l))
\end{lstlisting}
\begin{proof}
By induction on $n$.
When $n$ is zero, there is only one sorted list generated, which is the empty list, and we know that the empty list is sorted thanks to the constructor $NilIsSorted$. When n is some successor $(S\ pn)$, we know by using recursively the lemma on the smaller value $pn$ that all sorted lists of size $pn$ are sorted according to $isSorted$. Since the $Stream$ of all sorted lists of size $(S\ pn)$ has been made from the $Stream$ of all sorted lists of size $pn$ by adding to all of them --on the head position-- an element lower or equal to the current heads, we know that the property has been preserved at the higher rank.
\qed
\end{proof}

This lemma has the advantage of not requiring the predicate to be decidable, when this was needed in the previous section where we automatically tested the predicate on a finite observation. However, one could object that this lemma is itself built by using a predicate, $All$, and that we can't necessary trust blindly such a specification. The answer is that no guarantee is perfect, and all we can do is to add more guarantee, but there is always something to trust. Moreover, this new kind of specifications and proofs --about the predicate itself-- use more primitive components like streams and the predicate $All$, and these components can be provided once and for all. If they are part of some standard library being used intensively, there is very low risk that they don't capture the desired semantic.

In the other direction, we can prove that when the predicate $isSorted$ holds on some list, then this list is one of the list produced by the generator. The proof is done by induction on the list. For a singleton $[x]$, the proof uses the fact that $T$ is recursively enumerable, which means that the map has hit any value, and thus in particular $x$. When there are two or more elements, we know that $isSorted$ holds on the smaller list deprived from its head by construction. We finish the proof by using the lemma recursively on this smaller list together with the fact that the head is lower than the next element and the fact that the map is surjective.\qed
