	\section{Introduction}

There are multiple ways for increasing confidence in the software we build. One of them is to formally prove its correctness, using a proof assistant. These proofs assistants enable to write code, logical statements and proof in the same language, and offer the guarantee that every proof will be automatically checked. The appearance of these languages, and the way to write programs in them, varies from one to another. Many of them are functional programming languages, like Coq, Idris and Agda, and others, like the B-Toolkit belong to the imperative paradigm. These different paradigm are internally supported by different logic. Systems like Coq, Idris and Agda are based on various higher order logic (CoC, a variant of ML and LUO respectively) and are realisations of the Curry-Howard correspondence, while the formal B method is based on Hoare logic. These different foundations lead to different philosophies and different ways to implement and verify a software, but all of them greatly increase the confidence of the produced software. However, these guarantee tend to be too often consider as perfect, when they are in fact far from it. Knuth was --certainly ironically-- saying ``Beware of bugs in the above code; I have only proved it correct, not tried it". The reality is precisely that a proof isn't enough. When we prove the correctness of a function, we only gain the guarantee expressed by the proven lemma, and nothing more. 

Say we want to implement a formally verified sorting function that works for list of elements of type $T$, where $T$ is ordered by a relation $\leq$.
We can decide to put more or less information inside the type of the sorting function $sort$, in order to make it more or less explicit that this function is precisely a sorting function. We can decide to only use a ``weak" type, like $sort\ :\ \{T:Type\}\ \rightarrow\ List\ T\ \rightarrow\ List\ T$, and to use an external lemma to ensure the correctness of the function. Which property does this function has to respect ? First, the output has to be sorted. So first, we need to define this notion of being sorted. For this, we can define an inductive predicate.

\begin{lstlisting}
data isSorted : {T:Type} -> (Tord : Order T) 
                 -> (l:List T) -> Type where
    NilIsSorted : (Tord : Order T) -> isSorted Tord []
    SingletonIsSorted : (Tord : Order T) -> (x:T) -> isSorted Tord [x]
    ConsSorted : {Tord : Order T} -> (h1:T) -> (h2:T) -> (l:List T) 
                 -> (isSorted Tord (h2::t)) -> (h1 $\leq$ h2) 
                 -> (isSorted Tord (h1::(h2::t)))
\end{lstlisting}

The first and second constructor of this predicate says that $[\ ]$ and $[x]$ are sorted according to any order order, and for any $x$. The third one says that a list of two or more elements is sorted if the head $h1$ is lower or equal than the next element $h2$, and if the list deprived from its head is also sorted.

In order to express that the result produced by the function $sort$ is sorted, we can write and prove the following lemma:
$sort\_correct : \forall\ (T:Type)\ (l:List\ T),\ isSorted\ (sort\ l)$

The problem with this specification is that it doesn't says anything about the content of the output. The function $sort$ could just return the empty list $[\ ]$ all the time, it would still be possible to prove this correctness lemma. Indeed, this formal specification only says that the result should be sorted according to $isSorted$, and since $[\ ]$ is sorted (by $NilIsSorted$), this wrong implementation would be seen as ``correct". Here, the problem is that the function is underspecified, and it is therefore possible to write a senseless implementation, which is unfortunately seen as correct. Only a careful reader could realize that the lemma $sort\_correct$ forgets to mention that the input and output list should be in bijection, meaning that everything which was originally in the input list should still be in the output, and that nothing else should have been added.

Things more nasty can happen. Imagine that the third constructor of $isSorted$, called $consSorted$ would have been written with a typo, and that the condition $(h1 \leq h2) $ would have been incorrectly written as $(h1 \leq h1)$. Then, the function $sort$ could do whatever it wants, its result would be seen as ``sorted". For example, if the bijection condition has been added to the formal specification --and we can't therefore return $[\ ]$--, it would for example be possible to return the exact input, unchanged. Such a function would also unintentionally be seen as ``correct". One could object that the person doing the proof of correctness should realize that the proof is being done too easily, without having to use the essential property that the output is being built such as any element in the list is always lower or equal than the next element in the list. The reality is that currently, many effort are going in the direction of proof automation, where the machine builds the proof automatically. Many proof assistants are enhanced regularly with new automations that solves automatically some kind of goals. For example, Coq has already a Ring prover~\cite{coq2005}, a solver for Presburger arithmetic, and many others automations, and Idris has been recently equipped with a hierarchy of provers for algebraics structures [ref]. There are even extensions to languages, such as Ltac~\cite{DelahayeLTac} and Mtac~\cite{Ziliani13} that aim to help the automation of tactics.  Thus, the general tendency is precisely to let the machine find the proof on its own, and to only interact with the system when needed. And in the imperative world, the formal B-method also follows the same spirit, with many routine proofs being proven automatically. The problem is that the machine is never going to find a proof ``too easy", and will never report that something seems weird with the specification given by the user. We can't reasonably demand that the user of the proof assistant should read all of the automatically generated proof, looking for proofs that seem ``too easy" in order to find weaknesses in the specifications.

Thus, if we want to trust the proven software, we're now forced to believe that there is adequacy between the formal specification --written in some formal logic-- and the informal requirements. A switch has occurred. We used to have to trust code, but we now have to trust logical statements and predicates. But when the specification is too often as complicated as the code, why should we blindly believe in it, when we've first refused to blindly trust the code? Too few people realize that the proving activity has created this silent assumption of adequacy between the formalised specification and the original real requirements, usually written in english. Of course, the proving activity has undeniably increased the confidence in the produced software, and the aim of this paper isn't to say otherwise. Many successful applications of these formal methods, such as a formally verified C compiler \cite{Leroy09} have shown the value of developing a machined-checked proof of correctness. Instead, the primary aim of this paper is to raise awareness of the adequacy concern, and to see how heterogeneous approaches, that mix both proofs and tests, can help to go a step forward in the certification process, in the context of proof assistants based on type theory.
More precisely, we :
\begin{itemize}
\item Show the usual and naive approaches to the problem of a badly specified function which leads to a proof that does not convey the expected guarantee (section 2)
\item Show the distinction between structural properties, and the properties on the content, and how to identify what needs to be tested for the former category (section 3).
\item Show a way to conduct these tests in the proof assistant itself, by automatically generating terms, and we present a technique to automate these tests as far as possible (section 4)
\end{itemize}

We use Idris~\cite{brady2013idris}, a dependently typed programming language that can also be seen as a proof assistant, but all the ideas that we present here can be applied to any proof assistant based on type theory.

